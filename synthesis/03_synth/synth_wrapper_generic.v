
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 25 2025 20:37:35

// Verification Directory fv/synth_wrapper 

module fulladder(X, Y, Ci, S, Co);
  input X, Y, Ci;
  output S, Co;
  wire X, Y, Ci;
  wire S, Co;
  wire w1, w2, w3;
  xor G1 (w1, X, Y);
  xor G2 (S, w1, Ci);
  and G3 (w2, w1, Ci);
  and G4 (w3, X, Y);
  or G5 (Co, w2, w3);
endmodule

module ripple_adder(X, Y, S, Co, Cin);
  input [3:0] X, Y;
  input Cin;
  output [3:0] S;
  output Co;
  wire [3:0] X, Y;
  wire Cin;
  wire [3:0] S;
  wire Co;
  wire n_14, w1, w2, w3;
  assign Co = 1'b0;
  fulladder u1(X[0], Y[0], Cin, S[0], w1);
  fulladder u2(X[1], Y[1], w1, S[1], w2);
  fulladder u3(X[2], Y[2], w2, S[2], w3);
  fulladder u4(X[3], Y[3], w3, S[3], n_14);
endmodule

module counter(clk, rst_n, sel, out);
  input clk, rst_n, sel;
  output [3:0] out;
  wire clk, rst_n, sel;
  wire [3:0] out;
  wire [3:0] temp;
  wire [3:0] next_out;
  wire Cout, n_14;
  ripple_adder u_add(.X (out), .Y ({temp[2], temp[2], temp[2], sel}),
       .S (next_out), .Co (Cout), .Cin (temp[2]));
  not g1 (temp[2], sel);
  not g6 (n_14, rst_n);
  CDN_flop \out_reg[0] (.clk (clk), .d (next_out[0]), .sena (1'b1),
       .aclr (n_14), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[0]));
  CDN_flop \out_reg[1] (.clk (clk), .d (next_out[1]), .sena (1'b1),
       .aclr (n_14), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[1]));
  CDN_flop \out_reg[2] (.clk (clk), .d (next_out[2]), .sena (1'b1),
       .aclr (n_14), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[2]));
  CDN_flop \out_reg[3] (.clk (clk), .d (next_out[3]), .sena (1'b1),
       .aclr (n_14), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[3]));
endmodule

module synth_wrapper(clk, rst_n, sel, out);
  input clk, rst_n, sel;
  output [3:0] out;
  wire clk, rst_n, sel;
  wire [3:0] out;
  wire n_5, \out_reg[0]_12 , \out_reg[1]_13 , \out_reg[2]_14 ,
       \out_reg[3]_15 ;
  counter u1(.clk (clk), .rst_n (rst_n), .sel (sel), .out
       ({\out_reg[3]_15 , \out_reg[2]_14 , \out_reg[1]_13 ,
       \out_reg[0]_12 }));
  not g1 (n_5, rst_n);
  CDN_flop \out_reg[0] (.clk (clk), .d (\out_reg[0]_12 ), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[0]));
  CDN_flop \out_reg[1] (.clk (clk), .d (\out_reg[1]_13 ), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[1]));
  CDN_flop \out_reg[2] (.clk (clk), .d (\out_reg[2]_14 ), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[2]));
  CDN_flop \out_reg[3] (.clk (clk), .d (\out_reg[3]_15 ), .sena (1'b1),
       .aclr (n_5), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (out[3]));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
